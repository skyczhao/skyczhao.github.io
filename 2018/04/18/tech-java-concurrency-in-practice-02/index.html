<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Java并发编程实践-笔记02 · 十三羽</title><meta name="description" content="Java并发编程实践-笔记02 - Tobin"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-110577953-1"></script><script type="text/javascript">window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-110577953-1');</script></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/CV" target="_self" class="nav-list-link">CV</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Java并发编程实践-笔记02</h1><div class="post-info">Apr 18, 2018</div><div class="post-content"><p>先回顾一下，已经有4天没更新了。其实上周五有准备要写一篇的，关于最近的面试。但是还没定下来就没敢随便发出来。而这周开始刚好又多个项目告急，实在没抽出时间更新。</p>
<p>今天想着无论如何都要更新一篇了。虽晚但也要完成。</p>
<p>主题也是读书笔记，关于线程带来的风险。</p>
<a id="more"></a>
<h4 id="线程带来许多好处，但同时其风险也是显然的"><a href="#线程带来许多好处，但同时其风险也是显然的" class="headerlink" title="线程带来许多好处，但同时其风险也是显然的"></a>线程带来许多好处，但同时其风险也是显然的</h4><ol>
<li>安全性问题<ul>
<li>线程安全性可能是非常复杂的。在没有充足同步的情况下，多个线程中的操作执行顺序是不可预测的，甚至会产生奇怪的结果。</li>
<li>竞态条件(Race Condition)是一种常见的并发安全问题。</li>
</ul>
</li>
<li>活跃性问题<ul>
<li>活跃性关注的目标，即”某件正确的事情最终会发生”。但某个操作无法继续执行下去时，就会发生活跃性问题。</li>
<li>串行程序中，活跃性问题的形式之一就是无意中造成的无限循环。</li>
<li>线程中，则是另外的表现形式，例如死锁：线程A等待线程B释放其持有的资源，而线程B永远都不会释放。  </li>
</ul>
</li>
<li>性能问题<ul>
<li>包含有单线程程序相同的性能问题</li>
<li>多线程还带来新的问题：上下文切换(Context Switch)操作的开销；同步机制的开销，增加共享内存总线的同步流量；</li>
</ul>
</li>
</ol>
<h4 id="并发性错误，通常是难以分析的"><a href="#并发性错误，通常是难以分析的" class="headerlink" title="并发性错误，通常是难以分析的"></a>并发性错误，通常是难以分析的</h4><ol>
<li>依赖于不同线程的事件发生时序，难以重现</li>
</ol>
<p><strong>本文作者</strong>：Tobin<br><strong>本文地址</strong>： <a href="http://www.thirteenyu.com/2018/04/18/tech-java-concurrency-in-practice-02/">http://www.thirteenyu.com/2018/04/18/tech-java-concurrency-in-practice-02/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</p>
</div></article></div></section><footer><div class="paginator"><a href="/2018/04/19/es-node-management/" class="prev">上一篇</a><a href="/2018/04/12/tech-apue-file-io/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'thirteenyu';
var disqus_identifier = '2018/04/18/tech-java-concurrency-in-practice-02/';
var disqus_title = 'Java并发编程实践-笔记02';
var disqus_url = 'http://www.thirteenyu.com/2018/04/18/tech-java-concurrency-in-practice-02/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//thirteenyu.disqus.com/count.js" async></script><div class="copyright"><p>Hosted by <a href="https://pages.github.com">Github Pages</a> / <a href="https://pages.coding.me">Coding Pages</a></p><p>© 2010 - 2019 <a href="http://www.thirteenyu.com">Tobin</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>